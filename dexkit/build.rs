use std::collections::HashSet;
use std::env::current_dir;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    let result = flatc_exec();
    match result {
        Ok(_) => println!("FlatBuffers code generation succeeded."),
        Err(e) => eprintln!("{}", e),
    }
}

fn get_flatc_path() -> PathBuf {
    let mut path = current_dir().unwrap();
    path.push("flatc");
    if cfg!(target_os = "windows") {
        path.set_extension("exe");
    }
    path
}

fn get_flatc_version() -> Result<String, String> {
    let output = Command::new(get_flatc_path())
        .arg("--version")
        .output()
        .map_err(|e| format!("Failed to execute flatc: {}", e))?;

    if !output.status.success() {
        return Err(format!(
            "flatc returned a non-zero exit code: {}",
            output.status
        ));
    }

    let version = String::from_utf8(output.stdout)
        .map_err(|e| format!("Invalid UTF-8 in flatc version output: {}", e))?;
    Ok(version.trim().to_string())
}

fn flatc_exec() -> Result<(), String> {
    let flatc_path = get_flatc_path();
    println!("Using flatc at: {}", flatc_path.display());

    let flatc_version = get_flatc_version()?;
    println!("flatc version: {}", flatc_version);

    let schema_path = "../dexkit-sys/external/DexKit/schema/fbs";
    let out_dir = std::env::var("OUT_DIR").unwrap();

    let fbs = [
        format!("{}/encode_value.fbs", schema_path),
        format!("{}/enums.fbs", schema_path),
        format!("{}/matchers.fbs", schema_path),
        format!("{}/querys.fbs", schema_path),
        format!("{}/ranges.fbs", schema_path),
        format!("{}/results.fbs", schema_path),
    ];

    // Bug: `{out_path}/mod.rs` 尽管被生成了，但没有包含所有的子模块, 所以这里单独处理
    //
    // let output_path = Path::new(&out_dir).join("flatbuffers");
    // let output = Command::new(flatc_path)
    //     .args([
    //         "--rust",
    //         "--rust-module-root-file",
    //         "--gen-all",
    //         "-o",
    //         output_path.to_str().unwrap(),
    //     ])
    //     .args(&fbs)
    //     .output();
    // println!("{:?}", output);

    // 单独处理每个 fbs 文件
    let flatbuffers_generate_path = Path::new(&out_dir).join("flatbuffers_generate");
    let output_path = Path::new(&out_dir).join("flatbuffers/dexkit/schema");

    if output_path.exists() {
        fs::remove_dir_all(&output_path)
            .map_err(|e| format!("Failed to remove existing output directory: {}", e))?;
    }
    fs::create_dir_all(&output_path)
        .map_err(|e| format!("Failed to create output directory: {}", e))?;

    // 对每个 fbs 文件单独生成代码
    for item in fbs {
        Command::new(&flatc_path)
            .args([
                "--rust",
                "--rust-module-root-file",
                "--gen-all",
                "-o",
                &flatbuffers_generate_path.to_str().unwrap(),
            ])
            .arg(&item)
            .output()
            .map_err(|e| format!("Failed to execute flatc: {}", e))?;
    }

    // 遍历文件夹，输出所有生成的文件名
    let mut mod_set = HashSet::<String>::new();
    let generate_path = flatbuffers_generate_path.join("dexkit/schema"); // flatbuffers_generate/dexkit/schema
    let generate_dir =
        fs::read_dir(&generate_path).map_err(|e| format!("Failed to read directory: {}", e))?;
    for entry in generate_dir {
        let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) != Some("rs") {
            continue;
        }

        let file_name = path.file_stem().and_then(|s| s.to_str()).unwrap(); // 获取文件名（不含扩展名）
        let new_entry = output_path.join(file_name).with_extension("rs"); // 目标路径
        fs::copy(&path, &new_entry).map_err(|e| format!("Failed to copy file: {}", e))?; // 复制文件到最终目录
        mod_set.insert(file_name.to_string()); // 添加到集合
    }
    fs::remove_dir_all(&flatbuffers_generate_path)
        .map_err(|e| format!("Failed to remove temporary output directory: {}", e))?; // 删除临时目录(含所有子文件)

    // 生成 mod.rs 文件
    let mut mod_content = String::new();
    mod_content.push_str("// @generated by build.rs\n");
    mod_content.push_str("pub mod dexkit {\n");
    mod_content.push_str("  use super::*;\n");
    mod_content.push_str("  pub mod schema {\n");
    mod_content.push_str("    use super::*;\n");
    for item in &mod_set {
        mod_content.push_str(&format!("    mod {};\n", item));
        mod_content.push_str(&format!("    pub use self::{}::*;\n", item));
    }
    mod_content.push_str("  } // schema\n");
    mod_content.push_str("} // dexkit\n");

    let mod_file_path = output_path
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("mod.rs");
    fs::write(&mod_file_path, mod_content)
        .map_err(|e| format!("Failed to write mod.rs file: {}", e))?;

    Ok(())
}
